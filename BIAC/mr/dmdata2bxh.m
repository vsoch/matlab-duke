function dmdata2bxh(dmdatafile,bxhfile,typeformat)
%DMDATA2BXH - Generate BXH header for DMOD file.
%
% Generate BXH header for DMDATA files created by CIGAL, FSCAN, DMREAD,
% DMWRITE (Jim Voyvodic's suite of software)
%
% dmdata2bxh(dmdatafile)
% dmdata2bxh(dmdatafile,bxhfile)
% dmdata2bxh(dmdatafile,bxhfile,typeformat)
%
% dmdatafile - filename of dmdata file source
%    bxhfile - filename for output BXH file
%              (default = dmdatafile.bxh)
% typeformat - string to determine how the DMDATA types are translated
%              into BXH datarec types. Valid values are:
%                PDIGM  - BXH datarec type is pdigmDMDATAtype (default)
%                DMDATA - BXH datarec type is dmdataDMDATAtype
%
%  Note: Use a typeformat of PDIGM for paradigm files generated by CIGAL.
% 
% See Also: READBXHDATA, READBXHHDR

% CVS ID and authorship of this code
% CVSId = '$Id: dmdata2bxh.m,v 1.8 2005/02/03 16:58:38 michelich Exp $';
% CVSRevision = '$Revision: 1.8 $';
% CVSDate = '$Date: 2005/02/03 16:58:38 $';
% CVSRCSFile = '$RCSfile: dmdata2bxh.m,v $';

% Check inputs & set defaults
error(nargchk(1,3,nargin));
if nargin < 2 | isempty(bxhfile), bxhfile=[dmdatafile,'.bxh']; end
if nargin < 3 | isempty(typeformat), typeformat='PDIGM'; end
if ~ischar(dmdatafile), error('dmdatafile must be a string!'); end
if ~ischar(bxhfile), error('bxhfile must be a string!'); end
if ~any(strcmp(typeformat,{'PDIGM','DMDATA'})),
  error('typeformat must be PDIGM or DMDATA');
end

% Check that input file exists
if ~exist(dmdatafile,'file')
  error(sprintf('dmdatafile (%s) does not exist!',dmdatafile));
end

% Don't overwrite output file
if exist(bxhfile,'file')
  error(sprintf('bxhfile (%s) already exists.  Please choose an new output filename or delete this file',bxhfile));
end

fid = [];  % Initialize for catch
try
  % Check format using magic key
  [fid,msg]=fopen(dmdatafile,'r','n');
  if fid==-1, error(emsg); end
  [magicKey,count]=fread(fid,6,'char=>char');
  if count ~= 6 | ~strcmp(magicKey','DMDATA')
    fclose(fid);
    error(sprintf('File %s is not a DMDATA file!',dmdatafile));
  end
  
  % Rewind the text file
  if fseek(fid,0,-1); error(sprintf('Unable to rewind file %s',dmdatafile)); end
  
  % Parse first line
  currLine=fgetl(fid);
  if ~ischar(currLine), 
    error(sprintf('Unable to read first line of file %s',dmdatafile));
  end
  [junk,currLine]=strtok(currLine);    % Magic Key
  [hdrSize,currLine]=strtok(currLine);
  hdrSize=str2double(hdrSize);         % Size of header
  [byteOrder,junk]=strtok(currLine);   % Byte order 
  
  % Determine byte order
  if strncmp(byteOrder,'abcd',4) | strncmp(byteOrder,'lsbfirst',4)
    byteOrder='lsbfirst';
  elseif strncmp(byteOrder,'dcba',4) | strncmp(byteOrder,'msbfirst',4)
    byteOrder='msbfirst';
  else
    error('Unable to determine byte order!');
  end
  
  % Rewind the text file
  if fseek(fid,0,-1); error(sprintf('Unable to rewind file %s',dmdatafile)); end
  
  % Read the whole header
  [dmodhdr,count]=fread(fid,hdrSize,'char=>char');
  if count ~= hdrSize, 
    error(sprintf('Unable to read entire DMDATA header (%d read, %d desired) from file %s',count,hdrSize,dmdatafile));
  end
  dmodhdr=dmodhdr';  % Make it a row vector.
  fclose(fid); % Close the file
catch
  % Close file if an error occurs
  if ~isempty(fid) & ismember(fid,fopen('all'))
    fclose(fid);
  end
  % Issue error
  emsg=lasterr;
  if isempty(emsg), emsg='Unknown error occured!'; end
  error(emsg);
end

% Get relative pathname for dmdatafile (if same directory as BXH file)
fulldmdatafile = dmdatafile;
fullbxhfile = bxhfile;
if isrelpath(fulldmdatafile), fulldmdatafile = [pwd filesep fulldmdatafile]; end
if isrelpath(fullbxhfile), fullbxhfile = [pwd filesep fullbxhfile]; end
[dmpathstr, dmname, dmext, dmver] = fileparts(fulldmdatafile);
[bxhpathstr, bxhname, bxhext, bxhver] = fileparts(fullbxhfile);
reldmdatafile = dmdatafile;
if strcmp(dmpathstr, bxhpathstr)
  reldmdatafile = [dmname dmext dmver];
end
  
% Process each line
[currLine,dmodhdr]=strtok(dmodhdr,sprintf('\n')); % Already parsed this information
if isempty(dmodhdr), error('Invalid first line in DMDATA header!'); end
[currLine,dmodhdr]=strtok(dmodhdr,sprintf('\n')); % Second line
if ~strcmp(currLine,'#     Type Wsiz      Address           NX     NY     NZ     NT');
  error('Invalid second line in DMDATA header!');
end

% Read first record line.
[recordLine,dmodhdr]=strtok(dmodhdr,sprintf('\n'));
dataRec_i=1;  % datarec index for bxh header
while ~isempty(dmodhdr)
  % Parse record line
  % #     Type Wsiz      Address           NX     NY     NZ     NT
  if ~strncmp(recordLine,'Record ',7)
    error('Invalid Record entry!  Line must start with ''Record''');
  end
  [parsedRecord]=sscanf(recordLine(8:end),'%d');
  if length(parsedRecord) ~= 7,
    error('Invalid Record entry! Incorrect number of arguments');
  end

  % Read Description line
  if isempty(dmodhdr),
    error('Missing text line for last entry!');
  end
  [descriptionLine,dmodhdr]=strtok(dmodhdr,sprintf('\n'));
  if ~strncmp(descriptionLine,'  Text: ',8)
    error('Invalid Text entry!  Line must start with ''  Text: ''');
  end
  descriptionLine=descriptionLine(9:end);

  % Determine element type 
  % TODO: Handle complex types and any other bits.
  if parsedRecord(2)==0,     % ASCII
    elementtype='ascii';
  else
    % First 6 bits - number of bytes
    numBits=bitand(parsedRecord(2),63);
    % bits 8 - floating point flag (0-int, 1-float)
    floatFlag=bitand(parsedRecord(2),64);
    % Check for unhandled cases. (negative number or bits 9-inf set) 
    if parsedRecord(2) > 127 | parsedRecord(2) < 0
      error('Unknown element type (Wsiz = %d)',parseRecord(2));
    end
    if ~floatFlag
      % Signed integer
      elementtype=sprintf('int%d',numBits);
    else
      % Floating point
      elementtype=sprintf('float%d',numBits);
    end
  end
  
  % Generate recordType using DMDATA "Type" number
  if strcmp(typeformat,'PDIGM'),
    recordType = sprintf('pdigm%d',parsedRecord(1));
  elseif strcmp(typeformat,'DMDATA'),
    recordType = sprintf('dmdata%d',parsedRecord(1));
  else
    error('Unknown typeformat!');
  end

  % CIGAL pdigm files consistently assign some DMDATA "Type" numbers to
  % particular types of data.  Use more descriptive named types for these
  % fields. 
%   % Remove these until we agree on some names.
%   if strcmp(typeformat,'PDIGM')
%     switch recordType
%       case 'pdigm_7'
%         recordType='pdigm_physioTimes';
%       case 'pdigm_8'
%         recordType='pdigm_respiratoryAmp';
%       case 'pdigm_9'
%         recordType='pdigm_cardiacAmp';
%         % TODO: Add more named types.
%     end
%   end
     
  % Extract dimension sizes & remove trailing singleton dimensions
  dimSizes=parsedRecord(4:7);
  % Find last non-singleton dimension (use 1 if all are singluar)
  ii=find(dimSizes>1); if isempty(ii), ii=1; else ii=ii(end); end
  dimSizes=dimSizes(1:ii);
  
  % Calculate filerecordsize and fileoffset (bytes)
  filerecordsize = prod(dimSizes).*local_sizeof(elementtype);
  fileoffset = parsedRecord(3);
  
  % Generate datarec
  hdr.bxh{1}.datarec{dataRec_i}.ATTRS.type.VALUE = recordType;
  hdr.bxh{1}.datarec{dataRec_i}.description{1}.VALUE = descriptionLine;
  hdr.bxh{1}.datarec{dataRec_i}.elementtype{1}.VALUE = elementtype;
  hdr.bxh{1}.datarec{dataRec_i}.byteorder{1}.VALUE = byteOrder;
  hdr.bxh{1}.datarec{dataRec_i}.filename{1}.VALUE = reldmdatafile;
  hdr.bxh{1}.datarec{dataRec_i}.fileoffset{1}.VALUE = fileoffset;
  hdr.bxh{1}.datarec{dataRec_i}.filerecordsize{1}.VALUE = filerecordsize;
  hdr.bxh{1}.datarec{dataRec_i}.dimension{1}.ATTRS.type.VALUE = 'x';
  hdr.bxh{1}.datarec{dataRec_i}.dimension{1}.size{1}.VALUE = dimSizes(1);
  if length(dimSizes) > 1
    hdr.bxh{1}.datarec{dataRec_i}.dimension{2}.ATTRS.type.VALUE = 'y';
    hdr.bxh{1}.datarec{dataRec_i}.dimension{2}.size{1}.VALUE = dimSizes(2);
  end
  if length(dimSizes) > 2
    hdr.bxh{1}.datarec{dataRec_i}.dimension{3}.ATTRS.type.VALUE = 'z';
    hdr.bxh{1}.datarec{dataRec_i}.dimension{3}.size{1}.VALUE = dimSizes(3);
  end
  if length(dimSizes) > 3
    hdr.bxh{1}.datarec{dataRec_i}.dimension{4}.ATTRS.type.VALUE = 't';
    hdr.bxh{1}.datarec{dataRec_i}.dimension{4}.size{1}.VALUE = dimSizes(4);
  end
  
  % Increment datarec counter
  dataRec_i=dataRec_i+1;
  
  % Read next record line.
  [recordLine,dmodhdr]=strtok(dmodhdr,sprintf('\n'));
end

% --- Add subtypes for records with duplicate types
% Get record types
datarecTypes = cell(1,length(hdr.bxh{1}.datarec));
for dataRec_i=1:length(datarecTypes)
  datarecTypes{dataRec_i}=hdr.bxh{1}.datarec{dataRec_i}.ATTRS.type.VALUE;
end

% Handle duplicate types.
uniqueDatarecTypes=unique(datarecTypes); % Find unique types
if length(uniqueDatarecTypes)~=length(datarecTypes)
  % Only check each type if there are duplicates
  for uniqueDataRecTypes_i=1:length(uniqueDatarecTypes)
    % Check if there is more than one record with this type
    recordWithType = find(strcmp(datarecTypes,uniqueDatarecTypes{uniqueDataRecTypes_i}));
    if length(recordWithType)~=1
      % Add subtype (0,1,2,3...) to each duplicated type.
      % Leave first record subtype blank (implicitly 0)
      for m=2:length(recordWithType)      
        hdr.bxh{1}.datarec{recordWithType(m)}.ATTRS.subtype.VALUE=num2str(m-1);
      end
    end
  end
end

% Add history entry
hdr.bxh{1}.history{1}.entry{1}.date{1}.VALUE=datestr(now,31);
hdr.bxh{1}.history{1}.entry{1}.description{1}.VALUE='Generated by dmdata2bxh';

% Set top level BXH parameters
hdr.bxh{1}.ATTRS.version.VALUE='1.0';
hdr.bxh{1}.NSDEFS.bxh='http://www.biac.duke.edu/bxh';
hdr.bxh{1}.NSDEFS.DEFAULT='http://www.biac.duke.edu/bxh';

% Write BXH header
writexml(hdr,bxhfile);

% -------------------- local_sizeof --------------------------------------
function typesize=local_sizeof(intype)
% Return the number of bytes for the specified type
%
%  typesize=local_sizeof(intype)
%    intype - string containing type name
%    typesize - size of type in bytes

if ~ischar(intype), error('Input type must be a string!'); end

switch intype
  case {'uchar','schar','int8','uint8','ascii'}, typesize=1;
  case {'int16','uint16'}, typesize=2;
  case {'single','float32','int32','uint32'}, typesize=4;
  case {'int64','uint64','double','float64'}, typesize=8;
  otherwise, error(sprintf('Unknown type %s',intype));
end

% Modification History:
%
% $Log: dmdata2bxh.m,v $
% Revision 1.8  2005/02/03 16:58:38  michelich
% Changes based on M-lint:
% Make unused CVS variables comments for increased efficiency.
% Remove unnecessary semicolon after function declarations.
% Remove unnecessary commas after try, catch, and else statements.
%
% Revision 1.7  2004/12/10 21:09:40  gadde
% Use relative path name for dmdatafile in BXH file.
%
% Revision 1.6  2003/10/22 15:54:37  gadde
% Make some CVS info accessible through variables
%
% Revision 1.5  2003/05/30 21:36:37  michelich
% Changed CIGAL to PDIGM.  Removed named types.
% Remove trailing singleton dimensions.
% Calculate and include filerecordsize field.
% Use new history entry format.
%
% Revision 1.4  2003/05/30 17:48:13  michelich
% Make 1d ASCII records row vectors.
%
% Revision 1.3  2003/03/25 22:16:27  michelich
% Added more descriptive types names.
%
% Revision 1.2  2003/03/25 22:13:43  michelich
% Added typeformat to support translating CIGAL DMDATA files into more
% descriptive datarec types.
%
% Revision 1.1  2002/12/18 18:30:21  michelich
% Initial import
%
